[
["index.html", "R style guide Welcome lintr and styler", " R style guide This work is an adaptation of the tidyverse style guide by Hadley Wickham, based on 2017-11-17 and 2018-05-15 snapshots taken from GitHub [license]. Welcome This is the R style guide applied at daqana. Most of what is typically regarded as a style guide can be found in section 2 Syntax. The first four sections of this guide deal with styling recommendations for scripting in R. The second part deals with R package development. The guide should not be seen as complete and will certainly see further enhancement. A best practices section for coding in R (do avoid these for loops 🙂) or our preferred settings when using RStudio might be added in the future. Let’s start. Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread. Just as with punctuation, while there are many code styles to choose from, some are more reader-friendly than others. The style presented here is based on the style guide, which is used throughout the tidyverse, and which in turn is derived from Google’s R style guide and has evolved considerably over the years. Some decisions genuinely do make code easier to use (especially matching indentation to programming structure) and we try to explain these choices, but many decisions are arbitrary or a matter of taste. The more important thing about a style guide is that it provides consistency if applied consistently. # Good Throughout this guide positive examples are shown on a green background. # Bad Negative examples are shown on a pink background. The colors were chosen from a diverging colorblind friendly scheme (and some transparency has been added). Tips got a lightgrey background like any inline code. lintr and styler Conformance with a good portion of this style guide can be checked in an automated manner thanks to the lintr package (development version 1.0.2.9000 at the time of writing). The availability of specific linters is mentioned in the corresponding sections. A unit test bundling the customized linters is given in the Unit Tests lintr section of this guide. The styler package not only checks compliance with a specified style guide but also applies its rules to any discrepancies encountered. The package evolved from a Google Summer of Code project in 2017 and is under active development. It is tidyverse-oriented, i.e. its rules so far ensure compliance with aspects of the tidyverse style guide. Minor aspects are directly customizable, others would require their own rules to be written. We are planning to bundle the existing customized rules into a daqana_style() function and might extend it to widly cover this guides recommendations. The rules already covered (spaces, indention, line breaks and tokens) will be mentioned throughout the text. RStudio add-ins exist for both packages with default settings. To customize the linter add-in (on a per project basis) add the daqana_linters.R file (detailed in section 6) and a .lintr config file to your RStudio project directory. The config file should simply look like the following (mind the newline): linters: source(&quot;daqana_linters.R&quot;); daqana_linters At daqana with our internal package dqutils(&gt;=0.0.26) you can easily edit the .lintr config file to look like the following instead and ignore saving daqana_linters.R in your package directory. linters: dqutils::daqana_linters last modified: 2018-12-10 "],
["files.html", "1 Files 1.1 Names 1.2 Paths 1.3 Structure 1.4 Cleaning up", " 1 Files 1.1 Names File names should be meaningful and end in .R. Avoid using special characters in file names - stick with numbers, letters, -, and _. # Good fit_models.R utility_functions.R # Bad fit models.R foo.r stuff.r If files should be run in a particular order, prefix them with numbers. If it seems likely you’ll have more than 10 files, left pad with zero: # Good 00_download.R 01_explore.R ... 09_model.R 10_visualize.R If you later realise that you’ve missed some steps, it’s tempting to use 02a, 02b, etc. However, it’s generally better to bite the bullet and rename all files. Pay attention to capitalization, since you, or some of your collaborators, might be using an operating system with a case-insensitive file system (e.g., Microsoft Windows or OS X) which can lead to problems with (case-sensitive) revision control systems. Prefer file names that are all lower case, and never have names that differ only in their capitalization. 1.2 Paths When referring to files from within your script make sure not to use absolute paths. For portability reasons build paths with the file.path() function. # Bad &quot;/home/user/my_analysis_dir/data/survey_xy/my_data.csv&quot; # Good # you can check the working dir with getwd(), it should be set to your analysis dir file.path(&quot;data&quot;, &quot;survey_xy&quot;, &quot;my_data.csv&quot;) survey_xy_dir &lt;- file.path(&quot;data&quot;, &quot;survey_xy&quot;) file.path(survey_xy_dir, &quot;my_data.csv&quot;) file.path(survey_xy_dir, &quot;my_other_data.csv&quot;) Linters absolute_path_linter and nonportable_path_linter can check file paths. We currently do not use them as in our experience they fail to detect absolute and nonportable paths. We might write our own linters for that purpose. 1.3 Structure Use commented lines of - (or =) to break up your file into easily readable chunks. Be consistent. # Good # Load data =========================== load(&quot;my_data.RData&quot;) # Plot data =========================== plot(my_data$height ~ my_data$age) # Bad # Load data =========================== load(&quot;my_data.RData&quot;) #Plot data ------------------------------------------------- plot(my_data$height ~ my_data$age) #-------- # do some other stuff summary(my_data) In data analysis code, use comments to record important findings and analysis decisions. If you need comments to explain what your code is doing, consider rewriting your code to be clearer. If you discover that you have more comments than code, consider switching to RMarkdown. Start the script with a settings section sourcing and loading external files and packages and setting global variables and options. (With global we mean within your analysis or project, not R’s global options.) If you organize your project as a package (recommended) you can and should avoid load() and source(). source() can be very helpful, though, for keeping reports and apps well-arranged when they grow larger. # Good # ----------------------------------------------------------------------------- # settings requireNamespace(&quot;package_name&quot;, quietly = TRUE) load(&quot;my_data.RData&quot;) source(&quot;helper_functions.R&quot;) my_red &lt;- rgb(229, 29, 41, maxColorValue = 255) # ----------------------------------------------------------------------------- # data cleaning # ... # ----------------------------------------------------------------------------- # data exploration summary(my_cleaned_data) plot(my_cleaned_data$height ~ my_cleaned_data$age) # ----------------------------------------------------------------------------- If your script uses add-on packages, check their availability all at once at the very beginning of the file. This is more transparent than sprinkling library() calls throughout your code or having hidden dependencies that are loaded in a startup file, such as .Rprofile. # Good requireNamespace(&quot;package_name&quot;, quietly = TRUE) requireNamespace(&quot;another_package&quot;, quietly = TRUE) # at daqana -- thanks to our internal dqutils package -- you can also use required_packages &lt;- c(&quot;package_name&quot;, &quot;another_package&quot;, &quot;yet_another_package&quot;) dqutils::requireNamespaces(packages = required_packages, quietly = TRUE) You could load all the packages via calls to library() or – as recommended – only check their availability via requireNamespace(), and refer to all non-base functions explicitly via package::function(). The same function names might have been assigned in different packages with almost certainly differing aims, scopes and implementations. Using the package::function() format makes it explicit and rises awareness of which function is meant to be used and which packages they belong to. To use this format is also best practice within package code! # Good dplyr::filter(my_data, age &gt; 16) Omit the package:: prefix only if you refer to a function from an R base package like stats and graphics, which are typically loaded on start-up. Make sure that a single file does not get too long. Organize different steps of extensive analyses in separate files. Consider writing (helper) functions in seperate files (and source them at the beginning of your script) or in a package (and refer to them via my_package::my_function()). 1.4 Cleaning up During the development of your analysis scripts or functions you will repeatedly comment and uncomment lines of your code and probably also add todo comments. Obviously, when you are done you should clean up. There are two linters which check that there are no remaining lines of commented code (outside roxygen blocks, cf. section 5) and search for customizable todo phrases: commented_code_linter and todo_comment_linter (the latter expecting the code phrase immediately after the comment character, e.g. # to do: ....). Avoid unnecessary trailing white spaces. Though they won’t break your code as they might in other programming languages, you should still get rid of them even if only to save some otherwise unnecessarily required storage space. In order to avoid spurious commits in your version control system check for trailing white spaces already during development. In RStudio go to Global Options &gt; Code &gt; Saving and set Strip trailing horizontal whitespace when saving. It is applied to R scripts but not to Rmd scripts where trailing white spaces have their purpose (cf. RStudio commit). Alternatively, there is the trailing_whitespace_linter which spots all trailing white spaces regardless of file type. You should also set Ensure that source files end with newline. The newline character at the end of a line (also EOL character) ensures that whatever comes after belonges to a new line. To avoid unwanted behavior, source scripts should always have an EOL character at the end of their last lines. "],
["Syntax.html", "2 Syntax 2.1 Object names 2.2 Spacing 2.3 Indenting 2.4 Long lines 2.5 Assignment 2.6 Semicolons 2.7 Quotes", " 2 Syntax 2.1 Object names “There are only two hard things in Computer Science: cache invalidation and naming things.” — Phil Karlton Variable and function names should use only lowercase letters, numbers, and underscores (_). Use _ to separate words within a name (snake_case style). Using a seperator like the underscore increases readability in contrast to lowerCamelCase or UpperCamelCase. Base R uses dots in function names (contrib.url()) and class names (data.frame), but it’s better to reserve dots exclusively for the S3 object system. In S3, methods are given the name function.class; if you also use . in function and class names you end up with confusing methods like as.data.frame.data.frame(). Generally, variable names should be nouns and function names should be verbs. Strive for names that are concise and meaningful (this is not easy!) and that are not too long. # Good day_one day_1 # Bad first_day_of_the_month DayOne dayone day.one djm1 Check object names with object_name_linter(style = &quot;snake_case&quot;) and object_length_linter(length = 20L). Where possible, avoid re-using names of common functions and variables. This will cause confusion for the readers of your code. # Bad T &lt;- FALSE c &lt;- 10 mean &lt;- function(x) sum(x) 2.2 Spacing Put a space before and after all infix operators like =, +, -, &lt;-, ~ etc. Do without space around ^, / and * if you feel it would increase the readability, following the principle of multiplication and division first, then addition and subtraction. Also cf. operator precedence in R. Always put a space after a comma, and never before (just like in regular English). # Good average &lt;- mean(feet / 12 + inches, na.rm = TRUE) average &lt;- mean(feet/12 + inches, na.rm = TRUE) x ^ y sqrt(x^2 + y^2) y ~ x # Bad average&lt;-mean(feet/12+inches,na.rm=TRUE) y~x For the comma rule there is the commas_linter. The infix_spaces_linter strictly requires spaces around all infixes (also * /), thus we don’t use it. There’s another small exception to the spacing rule: don’t use spaces around :, ::, and :::. # Good x &lt;- 1:10 base::get() # Bad x &lt;- 1 : 10 base :: get() Extra spacing (i.e., more than one space in a row) is ok if it improves alignment of equal signs or assignments (&lt;-). # Good list( total = a + b + c, mean = (a + b + c) / n ) list( total = a + b + c, mean = (a + b + c) / n ) Place a space before (, but not when it’s part of a function call. # Good if (debug) { show(x) } plot(x, y) # Bad if(debug)show(x) plot (x, y) Check these spacing rules with spaces_left_parentheses_linter and function_left_parentheses_linter. Do not place spaces around code in parentheses or square brackets (unless there’s a comma, in which case see above). For curly braces see section 2.3 below. # Good if (debug) { do(x) } diamonds[5, ] # Bad if ( debug ) do(x) # No spaces around debug x[1,] # Needs a space after the comma x[1 ,] # Space goes after comma not before This can be checked with the spaces_inside_linter. 2.3 Indenting Curly braces, {}, define the most important hierarchy of R code. To make this hierarchy easy to see, always indent the code inside {} by two spaces. A symmetrical arrangement helps with finding related braces. A { should never go on its own line and should always be followed by a new line. A } should always go on its own line, unless it’s followed by else or ). Check your code for this behaviour with open_curly_linter and closed_curly_linter. # Good if (y &lt; 0 &amp;&amp; debug) { message(&quot;y is negative&quot;) } if (x &gt; 0) { message(&quot;x is positive&quot;) } else { message(&quot;x is negative or zero&quot;) } testthat::test_that(&quot;call1 should return an ordered factor&quot;, { testthat::expect_s3_class(call1(x, y), c(&quot;factor&quot;, &quot;ordered&quot;)) }) # Bad if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;) if (y == 0) { if (x &gt; 0) { log(x) }else{ message(&quot;x is negative or zero&quot;) } } else { y^ x } Exception: For very short if (x) { y } statements that fit on one line {} can go in the same line and the code inside should be surrounded by single spaces. # Good x &lt;- if (y &lt; 20) { &quot;Too low&quot; } else { &quot;Too high&quot; } if (y != 0) { y ^ x } else { if (x &gt; 0) { log(x) } else { message(&quot;x is negative or zero&quot;) } } if (y != 0) { y ^ x } else { if (x &gt; 0) { log(x) } else { message(&quot;x is negative or zero&quot;) } } Add argument allow_single_line = TRUE to the above linters to allow for the short statement exception. Because the closing brackets belong to the same level of hierarchy as the opening brackets they should not be indented. (Note that in RStudio auto-indention does not behave consistently. As a guide one can activate the Show indent guides checkbox via Global Options &gt; Code &gt; Display). The above holds both for curly and multi-line round brackets (e.g. in function calls or definitions as in 3.2). Always use spaces for indentation, never use tabs. The difficulty with tabs is that they are not defined distinctly in terms of columns or spaces (a space is always one column), i.e. results would differ depending on the environment. When using the RStudio IDE check the Insert spaces for tab checkbox and specify to Tab with 2 in the Global Options &gt; Code &gt; Editing tab. no_tab_linter also searches for tabs. 2.4 Long lines Strive to limit your code to 80 characters per line. This fits comfortably on a printed page with a reasonably sized font. If you find yourself running out of room, this is a good indication that you should encapsulate some of the work in a separate function. Lint long lines with line_length_linter(length = 80). If a function call is too long to fit on a single line, use one line each for the function name, each argument, and the closing ). This makes the code easier to read and to change later. # Good do_something_very_complicated( something = &quot;that&quot;, requires = many, arguments = &quot;some of which may be long&quot; ) # Bad do_something_very_complicated(&quot;that&quot;, requires, many, arguments, &quot;some of which may be long&quot; ) You may also place several arguments on the same line if they are closely related to each other, e.g., strings in calls to paste() or stop(). When building strings, where possible match one line of code to one line of output. # Good paste0( &quot;Requirement: &quot;, requires, &quot;\\n&quot;, &quot;Result: &quot;, result, &quot;\\n&quot; ) # Bad paste0( &quot;Requirement: &quot;, requires, &quot;\\n&quot;, &quot;Result: &quot;, result, &quot;\\n&quot;) Whenever you have to write long strings that won’t fit into one line, consider splitting them into smaller parts and joining those parts using paste(). This is not entirely elegant but conformes with the 80 char rule and ensures readability. For file paths use file.path(). 2.5 Assignment Use &lt;-, not =, for assignment. # Good x &lt;- 5 # Bad x = 5 5 -&gt; x Lint = assignments with assignment_linter. 2.6 Semicolons Don’t put ; at the end of a line, and don’t use ; to put multiple commands on one line. # Bad summary(data); x &lt;- 5; y &lt;- 2 * x # Good summary(data) x &lt;- 5 y &lt;- 2 * x Lint semicolons with semicolon_terminator_linter(semicolon = c(&quot;compound&quot;, &quot;trailing&quot;)). 2.7 Quotes Use &quot;, not ', for quoting text. The only exception is when the text already contains double quotes and no single quotes. (This is really an arbitrary convention. Anyhow, please be consistent and stick to it.) # Good &quot;Text&quot; &#39;Text with &quot;quotes&quot;&#39; &#39;&lt;a href=&quot;http://style.tidyverse.org&quot;&gt;A link&lt;/a&gt;&#39; ## [1] &quot;Text&quot; ## [1] &quot;Text with \\&quot;quotes\\&quot;&quot; ## [1] &quot;&lt;a href=\\&quot;http://style.tidyverse.org\\&quot;&gt;A link&lt;/a&gt;&quot; cat(&#39;Text with &quot;quotes&quot;&#39;, &quot;\\n&quot;) cat(&#39;&lt;a href=&quot;http://style.tidyverse.org&quot;&gt;A link&lt;/a&gt;&#39;) ## Text with &quot;quotes&quot; ## &lt;a href=&quot;http://style.tidyverse.org&quot;&gt;A link&lt;/a&gt; # Bad &#39;Text&#39; &#39;Text with &quot;double&quot; and \\&#39;single\\&#39; quotes&#39; ## [1] &quot;Text&quot; ## [1] &quot;Text with \\&quot;double\\&quot; and &#39;single&#39; quotes&quot; cat(&#39;Text with &quot;double&quot; and \\&#39;single\\&#39; quotes&#39;) ## Text with &quot;double&quot; and &#39;single&#39; quotes Lint single quotes with single_quotes_linter. "],
["functions.html", "3 Functions 3.1 Naming 3.2 Head and body 3.3 Argument names 3.4 return() 3.5 Comments 3.6 Design", " 3 Functions 3.1 Naming Use verbs for function names, where possible. # Good add_row() permute() # Bad row_adder() permutation() 3.2 Head and body If a function’s arguments definition runs over multiple lines, start the definition in a second line indenting by two spaces. Every argument should go to its own line as well as the closing bracket followed by the opening curly brace ) { and a new line for the function body. An empty line after the opening and before the closing bracket of the body further increase readability. # Good long_function_name &lt;- function( a = &quot;a long argument&quot;, b = &quot;another argument&quot;, c = &quot;another long argument&quot; ) { # As usual code is indented by two spaces. } # Bad long_function_name &lt;- function(a = &quot;a long argument&quot;, b = &quot;another argument&quot;, c = &quot;another long argument&quot;) { # Here the first argument might be overlooked # and it is a bit harder to spot where the head of the function ends # and the body of the function begins } 3.3 Argument names A function’s arguments typically fall into two broad categories: one supplies the data to compute on; the other controls the details of computation. When you call a function, you typically omit the names of data arguments, because they are used so commonly. Specify the non-data arguments explicitly and with the full name, avoid partial matching. # Good mean(1:10, na.rm = TRUE) mean(1:10, trim = 0.1) # Bad mean(x = 1:10, , FALSE) mean(, TRUE, x = c(1:10, NA)) mean(1:10, tr = 0.1) Aside: Avoid abbreviations of logicals, alway use TRUE and FALSE, never use T and F. # Good mean(1:10, na.rm = TRUE) my_vector[my_index] &lt;- FALSE # Bad mean(x = 1:10, na.rm = T) my_vector[my_index] &lt;- F There is a linter for spotting T and F symbols: T_and_F_symbol_linter. 3.4 return() Only use return() for early returns. Otherwise rely on R to return the result of the last evaluated expression. # Good find_abs &lt;- function(x, y){ if (x &gt; 0) { return(x) } -1 * x } add_two &lt;- function(x, y) { x + y } # Bad add_two &lt;- function(x, y) { return(x + y) } If your function is called primarily for its side-effects (like printing, plotting, or saving to disk), it should return the first argument invisibly. (This makes it possible to use the function as part of a pipe.) print methods should usually do this, like this example from httr: # Good print.url &lt;- function(x, ...) { cat(&quot;Url: &quot;, build_url(x), &quot;\\n&quot;, sep = &quot;&quot;) invisible(x) } 3.5 Comments In code, use comments to explain the Why rather than the What or How. Each line of a comment should begin with the comment symbol and a single space: # comment. Your function code (the What and How) should be self-explanatory. Comment the What as a headline of a codeblock optionally surrounded by lines of - or = to structure your script. Within functions this should rarely be necessary, as functions should not become too long. At daqana we agreed upon writing comments in English, and more specifically to use American English (AE), i.e. write color not colour, use optimize not optimise etc. 3.6 Design There are two main design principles to bear in mind: A function should do one thing well. A function should be called either because it has side-effects or because it returns a value; not both. Strive to keep blocks within a function on one screen. 20-30 lines per function are common. For functions that are significantly longer, consider splitting into smaller functions. A function should be easily understandable in isolation. Avoid global options. If your function has a transient side-effect (i.e. you need to create a temporary file or set an option), clean up after yourself with on.exit(). "],
["pipes.html", "4 Pipes 4.1 Introduction 4.2 Spacing and indenting 4.3 No arguments 4.4 Long lines 4.5 Assignment", " 4 Pipes Please note The magrittr package offers the use of the pipe (%&gt;%) in R. The introduction below describes situations when you might want to use the pipe. To begin with, here are some notes on its downsides which should be kept in mind. The magrittr package must be loaded and attached to the search path via a call to library(). The pipe, thus, must not be used in package code. I also recommend not to use it when you write functions in general as you might decide later to include them into a package. In my opinion, the pipe should only be used in exploratory use of R, not in scripting. Here is why: Intermediate objects matter. You might not need them further in your analysis (that’s what intermediate means), but they are crucial for spotting mistakes and for error diagnostics. Always inspect your intermediate objects, to see if they actually look like what you expect and want them to. This is easy with named intermediate objects, but less feasible with nested function calls or pipes. The syntax of the pipe (nice when reading out loud) conflicts with usual R syntax and requires constantly switching the mindset when used together with regular functional R syntax. Although this might just be a matter of habit, it introduces some inconsistency and thus makes your code harder to read and more error-prone. The pipe is slightly slower than using regular function calls – see benchmarks in our internal dqutils package. If you decide to use the pipe anyway, follow the recommendations below. 4.1 Introduction Use %&gt;% when you find yourself composing three or more functions together into a nested call, or creating intermediate objects that you don’t care about. Put each verb on its own line. This makes it simpler to rearrange them later, and makes it harder to overlook a step. It is ok to keep a one-step pipe in one line. (But then, why use the pipe?) Check that each step in a pipeline is on a new line, or the entire pipe fits on one line, with pipe_continuation_linter. For the example cf. Little Bunny Foo Foo # Good bopped &lt;- foo_foo %&gt;% hop(through = forest) %&gt;% scoop(up = field_mouse) %&gt;% bop(on = head) foo_foo %&gt;% fall(&quot;asleep&quot;) # ok fall(foo_foo, what = &quot;asleep&quot;) # better hopped &lt;- hop(foo_foo, through = forest) scooped &lt;- scoop(hopped, up = field_mice) bopped &lt;- bop(scooped, on = head) # intermediate objects which are no longer needed can be cleaned up rm(hopped, scooped) # Bad foo_foo &lt;- hop(foo_foo, through = forest) foo_foo &lt;- scoop(foo_foo, up = field_mice) foo_foo &lt;- bop(foo_foo, on = head) iris %&gt;% group_by(up) %&gt;% summarize_all(mean) %&gt;% ungroup %&gt;% gather(field_mice, foo_foo, -on) %&gt;% arrange(head) bop( # nesting 3 or more functions gets confusing scoop( # nesting 2 functions is ok hop(foo_foo, through = forest), up = field_mice ), on = head ) Avoid using the pipe when: You need to manipulate more than one object at a time. Reserve pipes for a sequence of steps applied to one primary object. There are meaningful intermediate objects that could be given informative names. Sometimes it seems useful to include a short pipe as an argument to a function in a longer pipe (which doesn’t require a lookup elsewhere). Avoid this, it decreases the readability of your code. It’s better to move the code outside the pipe and give it an evocative name. # Bad x %&gt;% select(a, b, w) %&gt;% left_join(y %&gt;% select(a, b, v), by = c(&quot;a&quot;, &quot;b&quot;)) x %&gt;% select(a, b, w) %&gt;% left_join( y %&gt;% filter(!u) %&gt;% gather(a, v, -b) %&gt;% select(a, b, v), by = c(&quot;a&quot;, &quot;b&quot;) ) # Good x_join &lt;- select(x, a, b, w) y_join &lt;- y %&gt;% filter(!u) %&gt;% gather(a, v, -b) %&gt;% select(a, b, v) left_join(x_join, y_join, by = c(&quot;a&quot;, &quot;b&quot;)) 4.2 Spacing and indenting %&gt;% should always have a space before it and a new line after it. After the first step, each line should be indented by two spaces. # Good iris %&gt;% group_by(Species) %&gt;% summarize_if(is.numeric, mean) %&gt;% ungroup() %&gt;% gather(measure, value, -Species) %&gt;% arrange(value) # Bad iris %&gt;% group_by(Species) %&gt;% summarize_all(mean) %&gt;% ungroup %&gt;% gather(measure, value, -Species) %&gt;% arrange(value) 4.3 No arguments magrittr allows you to omit () on functions that don’t have arguments. Avoid this. # Good x %&gt;% unique() %&gt;% sort() # Bad x %&gt;% unique %&gt;% sort 4.4 Long lines If the arguments to a function don’t all fit on one line, put each argument on its own line and indent: # Good iris %&gt;% group_by(Species) %&gt;% summarise( Sepal.Length = mean(Sepal.Length), Sepal.Width = mean(Sepal.Width), Species = n_distinct(Species) ) 4.5 Assignment Do not use -&gt; to create an object at the end of the pipe. Although it perfectly makes sense when using the pipe (reading out loud), it conflicts with usual R syntax. Use a separate line for the target of the assignment followed by &lt;-, it makes reading the code easier. Not only is this consistent with common R syntax, also the name acts as a heading, which reminds you of the purpose of the pipe. # Good iris_long &lt;- iris %&gt;% gather(measure, value, -Species) %&gt;% arrange(-value) # Bad iris_long &lt;- iris %&gt;% gather(measure, value, -Species) %&gt;% arrange(-value) iris %&gt;% gather(measure, value, -Species) %&gt;% arrange(-value) -&gt; iris_long "],
["help-pages.html", "5 Help Pages 5.1 Introduction 5.2 Title and Description 5.3 Indention 5.4 Documenting Parameters 5.5 Capitalization and Full Stops 5.6 Reference 5.7 Line Break 5.8 Code Font 5.9 Internal Functions 5.10 Deprecating Functions", " 5 Help Pages 5.1 Introduction Documentation of code is essential, even if the only person using your code is future-you. Use roxygen2 with enabled markdown support to keep your documentation close to the code. #` starts a roxygen comment, i.e. distinction from regular comments is through the backtick after the hashtag. These comments come before the object or function you are adding the documentation onto. All help pages of functions should specify the following tags: @title, @description, @param (one for each function parameter/argument), @return, @export (if the function is supposed to be visible outside of the package), @author (should be of form firstname.lastname at daqana) and @examples. If applicable, also use @family, @section, @keywords internal. Nice to have: @aliases, @seealso. 5.2 Title and Description For the title, describe concisely what the function does in the very first line of your function documentation. Titles should use sentence case but not end with a . (full stop). There is no need to use the explicit @title or @description tags, except in the case of the description if it is multiple paragraphs or includes more complex formatting like a bulleted list. I recommend to be explicit and, thus, to always use the tags. # Bad #&#39; @title #&#39; combine values #&#39; #&#39; @title #&#39; Combine values into a vector or list. #&#39; #&#39; Combine values into a vector or list #&#39; #&#39; This is a generic function which combines its arguments. #&#39; # Good #&#39; @title #&#39; Combine values into a vector or list #&#39; #&#39; @description #&#39; This is a generic function which combines its arguments. #&#39; #&#39; @title #&#39; Apply a function to each element of a vector #&#39; #&#39; @description #&#39; The map function transform the input, returning a vector the same length #&#39; as the input. `map()` returns a list or a data frame; `map_lgl()`, #&#39; `map_int()`, `map_dbl()` and `map_chr()` return vectors of the #&#39; corresponding type (or die trying); `map_dfr()` and `map_dfc()` return #&#39; data frames created by row-binding and column-binding respectively. #&#39; They require dplyr to be installed. 5.3 Indention Always indent with one space after #'. If any description corresponding to a roxygen tag spans over multiple lines, add another two spaces of extra indention. # Good #&#39; @param key The bare (unquoted) name of the column whose values will be used #&#39; as column headings. Alternatively, tags that span over multiple lines (like @description, @examples and @section) can have the corresponding tag on its own line and then subsequent lines don’t need extra indention. # Good #&#39; @examples #&#39; 1 + 1 #&#39; sin(pi) 5.4 Documenting Parameters For most tags, like @param, @seealso and @return, the text should be a sentence, starting with a capital letter and ending with a full stop. # Good #&#39; @param key The bare (unquoted) name of the column whose values will be used #&#39; as column headings. If some functions share parameters, you can use @inheritParams to avoid duplication of content in multiple places. # Tip #&#39; @inheritParams argument function_to_inherit_from 5.5 Capitalization and Full Stops For all bullets, enumerations, argument descriptions and the like, use sentence case and put a period at the end of each text element, even if it is only a few words. However, avoid capitalization of function names or packages since R is case sensitive. Use a colon before enumerations or bulleted lists. # Good #&#39; @details In the following, we present the bullets of the list: #&#39; * Four cats are few animals. #&#39; * forcats is a package. 5.6 Reference Cross-referencing is encouraged, both within R’s help file system as well as to external resources. Include parentheses after function names when referencing function calls. When referring to other sections in the documentation, use single quotes and title case. # Good #&#39; @seealso [fct_lump()] #&#39; @param p1 Another parameter. See &#39;Details&#39;. # Bad #&#39; @seealso [fct_lump] #&#39; @param p1 Another parameter. See &quot;details&quot;. If you have a family of related functions, you can use the @family tag with a shared family name to automatically add appropriate lists and interlinks to the @seealso section. Family names are plural. In dplyr, the verbs arrange(), filter(), mutate(), slice(), summarize() form the family of single table verbs. Each documentation contains the following line: # Tip #&#39; @family single table verbs 5.7 Line Break Leave one line blank before / after each description. # Good #&#39; @section Tidy data: #&#39; When applied to a data frame, row names are silently dropped. To preserve, #&#39; convert to an explicit variable with [tibble::rownames_to_column()]. #&#39; #&#39; @section Scoped filtering: #&#39; The three [scoped] variants ([filter_all()], [filter_if()] and #&#39; [filter_at()]) make it easy to apply a filtering condition to a #&#39; selection of variables. If you want to insert a line break within a section, also leave a line break in the roxygen comments. # Tip #&#39; @param ... Data frames to combine. #&#39; #&#39; Each argument can either be a data frame, a list that could be a data #&#39; frame, or a list of data frames. #&#39; #&#39; When row-binding, columns are matched by name, and any missing #&#39; columns with be filled with NA. #&#39; #&#39; When column-binding, rows are matched by position, so all data #&#39; frames must have the same number of rows. To match by value, not #&#39; position, see [join()]. 5.8 Code Font Text that contains valid R code should be marked as such using `code` (backticks around code). Function names, should be followed by (), e.g. tibble(). Function arguments, e.g. na.rm. Values, e.g. TRUE, FALSE, NA, NaN, ..., NULL Literal R code, e.g. mean(x, na.rm = TRUE) To refer to the R language, use \\R. Do not use code font for package names. If package name is ambiguous in the context, disambiguate with words, e.g. “the foo package”. 5.9 Internal Functions Internal functions should be documented with #' comments as per usual. Use the @noRd tag to prevent .Rd files from being generated. # Good #&#39; @title Drop last #&#39; #&#39; @description #&#39; Drops the last element from a vector. #&#39; #&#39; @param x A vector object to be trimmed. #&#39; #&#39; @noRd 5.10 Deprecating Functions The following example is taken from https://stackoverflow.com/a/10145627. # Good ## before #&#39; @title Alchemy function with too long name #&#39; @description Turn lead into gold. #&#39; @param lead Input material. #&#39; @return gold #&#39; @export transmute_my_carefully_crafted_data_structure_into_gold &lt;- function(lead) { # todo: figure out how to create gold # look like we are doing something Sys.sleep(10) return(&quot;gold&quot;) } ## after #&#39; @title Alchemy function with too long name #&#39; @description Deprecated function. Turn lead into gold. #&#39; @param lead Input material. #&#39; @return gold #&#39; @export #&#39; @rdname package-deprecated #&#39; @seealso \\code{\\link{alchemy}} transmute_my_carefully_crafted_data_structure_into_gold &lt;- function(lead) { .Deprecated(&quot;alchemy&quot;, package = &quot;your_package_name&quot;) alchemy(lead) } #&#39; @title Alchemy function with appropriate name #&#39; @description Turn lead into gold. #&#39; @param lead Input material. #&#39; @return gold #&#39; @export alchemy &lt;- function(lead) { # todo: figure out how to create gold # look like we are doing something Sys.sleep(10) return(&quot;gold&quot;) } "],
["unit-tests.html", "6 Unit Tests 6.1 Introduction 6.2 File names 6.3 Structure 6.4 Context 6.5 Property test lintr", " 6 Unit Tests 6.1 Introduction Unit tests help you maintain high quality and error free code that does what it is expected to do. Write unit tests for all of your functions and re-run them whenever you change any code. Try to capture as much of a functions code by any exceptions you can think of with dedicated unit tests. At daqana we agreed to use the powerful and easy-to-use testthat package. 6.2 File names File names of unit test code should follow the pattern test-filename-function_name.R. They must start with the word test in order to be recognized automatically. # Good test-add_two.R # for add_two() in add_two.R test-numericals-add_two.R # for add_two() in numericals.R # Bad add_two_test.R ut-add_two.R 6.3 Structure Suppose we have a file test-create_json.R and want to test create_json() in create_json.R. We start with setting the context, then specify the tests which are grouped by messages describing the tested properties. # context message will be shown on every of the following tests testthat::context(&quot;create_json()&quot;) # test_that message will be shown only if the test fails testthat::test_that(&quot;create_json() should create the expected JSON&quot;, { # the corresponding tests that must be passed testthat::expect_identical(create_json(input_1), expected_json_1) testthat::expect_identical(create_json(input_2), expected_json_2) }) # another property to be tested testthat::test_that(&quot;create_json() should return NULL for NULL input&quot;, { testthat::expect_null(create_json(NULL)) }) 6.4 Context At daqana we typically use a separate context for each function. The input to testthat::context() should then follow the pattern &quot;function_name&quot; or &quot;filename / function_name&quot; if more than one function reside in the same file (and filename thus is not identical with the function name). Generally, every function should live in its own file, though. # Good testthat::context(&quot;numericals / add_two&quot;) # if add_two() resides in numericals.R # the tests # Bad testthat::context(&quot;long unnecessary context for the tested function add_two&quot;) # the tests testthat::context(&quot;another context in same test file&quot;) # some other tests 6.5 Property test For every context the properties to be tested are organized by calls to testthat::test_that(), which in turn calls a variable number of property-related user-defined tests. The message to be shown if a property test fails should be written as a full sentence. It should state what the function was expected to return following the pattern &quot;function() should what-the-function-should-do-or-return (if applicable: under certain conditions)&quot;. # Good testthat::context(&quot;numericals / add_two&quot;) testthat::test_that(&quot;add_two() should return sum of two numerical values&quot;, { testthat::expect_identical(add_two(2, 3), 5) testthat::expect_identical(add_two(0, 0), 0) }) testthat::test_that( &quot;add_two() should throw an error for non-numerical inputs&quot;, { testthat::expect_error(add_two(&quot;foo&quot;, &quot;bar&quot;)) } ) # Bad testthat::context(&quot;long unnecessary context for the tested function add_two&quot;) # not describing what is being tested! testthat::test_that(&quot;everything works&quot;, { testthat::expect_identical(add_two(2, 3), 5) # pointless test testthat::expect_identical(add_two(1, 2), add_two(1, 2)) }) # empty description! testthat::test_that(&quot;&quot;, { testthat::expect_true(another_function(&quot;foo&quot;)) }) lintr Save the list of our customized linters to a file daqana_linters.R (click for download) and add it to your package project directory. # ----------------------------------------------------------------------------- daqana_linters &lt;- list( # Files # TODO dq_absolute_path_linter # cf. https://github.com/jimhester/lintr/issues/339 # TODO dq_nonportable_path_linter commented_code_linter = lintr::commented_code_linter, todo_comment_linter = lintr::todo_comment_linter( todo = c(&quot;todo&quot;, &quot;to do&quot;, &quot;TODO&quot;, &quot;TO DO&quot;) # custom argument ), # no default linter # Syntax object_name_linter = lintr::object_name_linter( style = &quot;snake_case&quot; ), object_length_linter = lintr::object_length_linter( length = 20L ), # TODO dq_infix_spaces_linter commas_linter = lintr::commas_linter, spaces_left_parentheses_linter = lintr::spaces_left_parentheses_linter, function_left_parentheses_linter = lintr::function_left_parentheses_linter, spaces_inside_linter = lintr::spaces_inside_linter, T_and_F_symbol_linter = lintr::T_and_F_symbol_linter, # no default linter open_curly_linter = lintr::open_curly_linter( allow_single_line = TRUE # custom argument ), closed_curly_linter = lintr::closed_curly_linter( allow_single_line = TRUE # custom argument ), no_tab_linter = lintr::no_tab_linter, line_length_linter = lintr::line_length_linter( length = 80L # custom argument ), assignment_linter = lintr::assignment_linter, semicolon_terminator_linter = lintr::semicolon_terminator_linter( c(&quot;compound&quot;, &quot;trailing&quot;) ), # no default linter single_quotes_linter = lintr::single_quotes_linter, # Pipes pipe_continuation_linter = lintr::pipe_continuation_linter#, # to be added in upcomming versions (code section) # extraction_operator_linter, # no default linter # implicit_integer_linter, # no default linter # undesirable_function_linter, # no default linter # undesirable_operator_linter, # no default linter # unneeded_concatenation_linter, # no default linter # seq_linter, # no default linter # not to be used # trailing_whitespace_linter # trailing_blank_lines_linter # object_usage_linter # equals_na_linter # no default linter # to be replaced by own versions # infix_spaces_linter # absolute_path_linter # no default linter # nonportable_path_linter # no default linter ) # ----------------------------------------------------------------------------- You can also add a .lintr config file as mentioned in the start page section lintr and styler, which would simply look like the following and should also reside in your package project directory. linters: source(&quot;daqana_linters.R&quot;); daqana_linters Test that there are no lints in your package. The linters are applied to all R files in the package. Files that should be excluded from checks can be passed to argument exclusions as a list of paths relative to path. Alternatively, add them to the config file. # without a config file testthat::context(&quot;Test style (lintr)&quot;) testthat::test_that(&quot;Style should be lint-free&quot;, { testthat::skip_if_not( requireNamespace(&quot;lintr&quot;, quietly = TRUE), message = &quot;Package lintr must be installed!&quot; ) # source(&quot;daqana_linters.R&quot;) # only needed when not using dqutils lintr::expect_lint_free( path = &quot;.&quot;, relative_path = TRUE, exclusions = NULL, # default settings linters = daqana_linters ) }) # or with our .lintr config file testthat::context(&quot;Test style (lintr)&quot;) testthat::test_that(&quot;Style should be lint-free&quot;, { testthat::skip_if_not( requireNamespace(&quot;lintr&quot;, quietly = TRUE), message = &quot;Package lintr must be installed!&quot; ) lintr::expect_lint_free() }) "],
["error-messages.html", "7 Error messages 7.1 Problem statement 7.2 Error location 7.3 Hints 7.4 Grammar 7.5 Examples", " 7 Error messages An error message should start with a general statement of the problem and then give a concise description of what went wrong. Consistent use of punctuation and formatting makes errors easier to parse. 7.1 Problem statement Every error message should start with a general statement of the problem. It should be concise, but informative. (This is hard!) If the cause of the problem is clear use must. Clear cut causes typically involve incorrect types or lengths. dplyr::nth(1:10, &quot;x&quot;) # GOOD ## Error: `n` must be a numeric vector, not a character vector. dplyr::nth(1:10, 1:2) # GOOD ## Error: `n` must have length 1, not length 2. If you cannot state what was expected, use can't: mtcars %&gt;% pull(b) # GOOD ## Error: Can&#39;t find column `b` in `.data`. as_vector(environment()) # GOOD ## Error: Can&#39;t coerce `.x` to a vector. purrr::modify_depth(list(list(x = 1)), 3, ~ . + 1) # GOOD ## Error: Can&#39;t find specified `.depth` in `.x`. Use stop(call. = FALSE), rlang::abort(), Rf_errorcall(R_NilValue, ...) to avoid cluttering the error message with the name of the function that generated it. That information is often not informative, and can easily be accessed via traceback() or an IDE equivalent. 7.2 Error location Do your best to reveal the location, name, and/or content of the troublesome component. The goal is to make it as easy as possible for the user to find and fix the problem. map_int(1:5, ~ &quot;x&quot;) # BAD ## Error: Each result must be a single integer # GOOD ## Error: Each result must be a single integer: ## * Result 1 is a character vector. (It is often not easy to identify the exact problem; it may require passing around extra arguments so that error messages generated at a lower-level can know the original source. For frequently used functions, the effort is typically worth it.) If the source of the error is unclear, avoid pointing the user in the wrong direction by giving an opinion about the source of the error: pull(mtcars, b) # GOOD ## Error: Can&#39;t find column `b` in `.data`. # BAD: implies one argument at fault ## Error: Column `b` must exist in `.data` ## Error: `.data` must contain column `b` tibble(x = 1:2, y = 1:3, z = 1) # GOOD ## Error: Columns must have consistent lengths: ## * Column `x` has length 2 ## * Column `y` has length 3 # BAD: implies one argument at fault ## Error: Column `x` must be length 1 or 3, not 2 If there are multiple issues, or an inconsistency revealed across several arguments or items, prefer a bulleted list: purrr::reduce2(1:4, 1:2, `+`) # GOOD ## Error: `.x` and `.y` must have compatible lengths: ## * `.x` has length 4 ## * `.y` has length 2 # BAD: harder to scan ## Error: `.x` and `.y` must have compatible lengths: `.x` has length 4 and ## `.y` has length 2 7.3 Hints If the source of the error is clear and common, you may want provide a hint as how to fix it: dplyr::filter(iris, Species = &quot;setosa&quot;) # GOOD ## Error: Filter specifications must be named. ## Did you mean `Species == &quot;setosa&quot;`? ggplot2::ggplot(ggplot2::aes()) # GOOD ## Error: Can&#39;t plot data with class &quot;uneval&quot;. ## Did you accidentally provide the results of aes() to the `data` argument? Hints should always end in a question mark. Hints are particularly important if the source of the error is far away from the root cause: mean[[1]] # BAD ## Error in mean[[1]] : object of type &#39;closure&#39; is not subsettable. # BETTER ## Error: Can&#39;t subset a function. # BEST ## Error: Can&#39;t subset a function. ## Have you forgotten to define a variable named `mean`? Good hints are difficult to write because, as above, you want to avoid steering users in the wrong direction. Generally, I avoid writing a hint unless the problem is common, and you can easily find a common pattern of incorrect usage (e.g. by searching StackOverflow). 7.4 Grammar Errors should be written in sentence case, and should end in a full stop. Bullets should be formatted similarly; make sure to capitalise the first word (unless it’s an argument or column name). Prefer the singular in problem statements: map_int(1:2, ~ &quot;a&quot;) # BAD ## Error: Results must be coercible to single integers: ## * Result 1 is a character vector # GOOD ## Error: Each result must be coercible to a single integer: ## * Result 1 is a character vector. If you can detect multiple problems, list up to five. This allows the user to fix multiple problems in a single pass without being overwhelmed by many errors that may have the same source. # BETTER ## Error: Each result must be coercible to a single integer: ## * Result 1 is a character vector ## * Result 2 is a character vector ## * Result 3 is a character vector ## * Result 4 is a character vector ## * Result 5 is a character vector ## * ... and 5 more problems Pick a natural connector between problem statement and error location: this may be , not, ;, or : depending on the context. Surround the names of arguments in backticks, e.g. `x`. Use column to disambiguiate columns (statistical variables) and arguments: Column `x`. Avoid the term variable, because it is ambiguous (statistics vs. computer science). Ideally, each component of the error message should be less than 80 characters wide. Do not add manual line breaks to long error messages; they will not look correct if the console is narrower (or much wider) than expected. Instead, use bullets to break up the error into shorter logical components. 7.5 Examples The process of improving error messages is illustrated below through before and after examples from around the tidyverse. dplyr::filter(mtcars, cyl) # before: ## Argument 2 filter condition does not evaluate to a logical vector # after: ## Each argument must be a logical vector: ## * Argument 2 (`cyl`) is an integer vector. tibble::tribble(&quot;x&quot;, &quot;y&quot;) #before: ## Expected at least one column name; e.g. `~name` # after: ## Must supply at least one column name, e.g. `~name`. ggplot2::ggplot(data = diamonds) + ggplot2::geom_line(ggplot2::aes(x = cut)) #before: ## geom_line requires the following missing aesthetics: y # after: ## `geom_line()` must have the following aesthetics: `y`. dplyr::rename(mtcars, cyl = xxx) #before: ## `xxx` contains unknown variables # after: ## Can&#39;t find column `xxx` in `.data`. dplyr::arrange(mtcars, xxx) #before: ## Evaluation error: object &#39;xxx&#39; not found. # after: ## Can&#39;t find column `xxx` in `.data`. "],
["news.html", "8 News 8.1 News bullets 8.2 Organisation 8.3 Blog post", " 8 News 8.1 News bullets Each user-facing change should be accompanied by a bullet in NEWS.md. The goal of the bullet is to briefly describe the change so users of the packages can understand what’s changed. This can be similar to the commit message, but often the commit message will be developer facing, and the bullet will be user facing. It is not necessary to describe minor documentation changes. But it’s worthwhile to draw attention to sweeping changes, and to new vignettes. New bullets should be added to the top of the file (under the version heading). Organisation of bullets will happen later, during the release process (as described below). 8.1.1 General style Strive to place the name of the function as close to the beginning of the bullet as possible. A consistent location makes the bullets easier to scan, and easier to organise prior to release. # Good * `ggsave()` now uses full argument names to avoid partial match warning (#2355). # Bad * Fixed partial argument matches in `ggsave()` (#2355). Lines should be wrapped to 80 characters, and each bullet should end in a full stop. Frame bullets positively (i.e. what now happens, not what used to happen), and use the present tense. # Good * `ggsave()` now uses full argument names to avoid partial match warnings (#2355). # Bad * `ggsave()` no longer partially matches argument names (#2355). If the bullet is related to an issue, include the issue number. If the contribution was a PR, and the author is not a package author, include their GitHub user name. Both items should be wrapped in parentheses and will generally come before the final period. # Good * `ggsave()` now uses full argument names to avoid partial match warnings (@wch, #2355). # Bad * `ggsave()` now uses full argument names to avoid partial match warnings. * `ggsave()` now uses full argument names to avoid partial match warnings. (@wch, #2355) Functions and arguments should be wrapped in back ticks, and function names should include parentheses. # Good * In `stat_bin()`, `binwidth` now also takes functions. # Bad * In the `stat_bin` function, the `binwidth` argument now also takes functions. Many news bullets will be a single sentence. This is typically adequate when describing a bug fix or minor improvement, but you may need more detail when describing a new feature. For more complex features, include longer examples in fenced code blocks (```). These will be useful inspiration when you later write the blog post. # Good * In `stat_bin()`, `binwidth` now also takes functions. # Better * In `stat_bin()`, `binwidth` now also takes functions. The function is called with the scaled `x` values, and should return a single number. This makes it possible to use classical binwidth computatons with ggplot2. # Best * In `stat_bin()`, `binwidth` now also takes functions. The function is called with the scaled `x` values, and should return a single number. With a little work, this makes it possible to use classical bin size computatons with ggplot2. ```R sturges &lt;- function(x) { rng &lt;- range(x) bins &lt;- nclass.Sturges(x) (rng[2] - rng[1]) / bins } ggplot(diamonds, aes(price)) + geom_histogram(binwidth = sturges) + facet_wrap(~ cut) ``` 8.1.2 Common patterns The following excerpts from tidyverse news entries provide helpful templates to follow. New family of functions * Support for ordered factors is improved. Ordered factors throw a warning when mapped to shape (unordered factors do not), and do not throw warnings when mapped to size or alpha (unordered factors do). Viridis is used as default colour and fill scale for ordered factors (@karawoo, #1526). * `possibly()`, `safely()` and friends no longer capture interrupts: this means that you can now terminate a mapper using one of these with Escape or Ctrl + C (#314). New function * New `position_dodge2()` provides enhanced dogding for boxplots... * New `stat_qq_line()` makes it easy to add a simple line to a Q-Q plot. This line makes it easier to judge the fit of the theoretical distribution (@nicksolomon). New argument to existing function: * `geom_segment()` gains a `linejoin` parameter. Function argument changes behaviour: * In `separate()`, `col = -1` now refers to the far right position. Previously, and incorrectly, `col = -2` referred to the far-right position. Function changes behaviour. * `map()` and `modify()` now work with calls and pairlists (#412). * `flatten_dfr()` and `flatten_dfc()` now aborts with informative message if dplyr is not installed (#454). * `reduce()` now throws an error if `.x` is empty and `.init` is not supplied. 8.2 Organisation Prior to release, the NEWS file needs to be thoroughly proof read and groomed. Each release should have a level 1 heading (#) containing the package name and version number. For smaller packages or patch releases this amount of organisation may be sufficient. For example, here is the NEWS for model 0.1.2: # modelr 0.1.2 * `data_grid()` no longer fails with modern tidyr (#58). * New `mape()` and `rsae()` model quality statistics (@paulponcet, #33). * `rsquare()` use more robust calculation 1 - SS_res / SS_tot rather than SS_reg / SS_tot (#37). * `typical()` gains `ordered` and `integer` methods (@jrnold, #44), and `...` argument (@jrnold, #42). If there are manymany bullets, the version heading should be following issues grouped into related areas with level 2 headings (##). Three commonly used sections are shown below: # package 1.1.0 ## Breaking changes ## New features ## Minor improvements and fixes It is fine to deviate from these headings if another organisation makes sense. Indeed, larger packages will often require a finer break down. For example, ggplot2 2.3.0 included these headings: # ggplot 2.3.0 ## Breaking changes ## New features ### Tidy evaluation ### sf ### Layers: geoms, stats, and position adjustments ### Scales and guides ### Margins ## Extension points ## Minor bug fixes and improvements ### Facetting ### Scales ### Layers ### Coords ### Themes ### Guides ### Other It is not worthwhile to organise bullets into headings during development, as it’s not typically obvious what the groups will be in advance. Within a section, bullets should be ordered alphabetically by the first function mentioned. If no function is mentioned, place at the top of the section. 8.2.1 Breaking changes If there are API breaking changes (as discovered during revdepchecks) these should also appear in their own section at the top. Each bullet should include a description of the symptoms of the change, and what is needed to fix it. The bullet should also be repeated in the appropriate section. ## Breaking changes * `separate()` now correctly uses -1 to refer to the far right position, instead of -2. If you depended on this behaviour, you&#39;ll need to condition on `packageVersion(&quot;tidyr&quot;) &gt; &quot;0.7.2&quot;`. 8.3 Blog post For all major and minor releases, the latest news should be turned into a blog post. The blog post should hightlight major user-facing changes, and point to the release notes for more details. Generally, you should focus on new features and major improvements, including examples showing the new features in action. You don’t need to describe minor improvements and bug fixes, as the motivated reader can find these in the release notes. "]
]
